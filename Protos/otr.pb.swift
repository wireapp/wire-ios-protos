//
// Wire
// Copyright (C) 2020 Wire Swiss GmbH
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program. If not, see http://www.gnu.org/licenses/.
//

// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: otr.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct UserId {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var uuid: Data {
    get {return _uuid ?? Data()}
    set {_uuid = newValue}
  }
  /// Returns true if `uuid` has been explicitly set.
  public var hasUuid: Bool {return self._uuid != nil}
  /// Clears the value of `uuid`. Subsequent reads from it will return its default value.
  public mutating func clearUuid() {self._uuid = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _uuid: Data? = nil
}

public struct ClientId {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var client: UInt64 {
    get {return _client ?? 0}
    set {_client = newValue}
  }
  /// Returns true if `client` has been explicitly set.
  public var hasClient: Bool {return self._client != nil}
  /// Clears the value of `client`. Subsequent reads from it will return its default value.
  public mutating func clearClient() {self._client = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _client: UInt64? = nil
}

public struct ClientEntry {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var client: ClientId {
    get {return _client ?? ClientId()}
    set {_client = newValue}
  }
  /// Returns true if `client` has been explicitly set.
  public var hasClient: Bool {return self._client != nil}
  /// Clears the value of `client`. Subsequent reads from it will return its default value.
  public mutating func clearClient() {self._client = nil}

  public var text: Data {
    get {return _text ?? Data()}
    set {_text = newValue}
  }
  /// Returns true if `text` has been explicitly set.
  public var hasText: Bool {return self._text != nil}
  /// Clears the value of `text`. Subsequent reads from it will return its default value.
  public mutating func clearText() {self._text = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _client: ClientId? = nil
  fileprivate var _text: Data? = nil
}

public struct UserEntry {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var user: UserId {
    get {return _user ?? UserId()}
    set {_user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  public var hasUser: Bool {return self._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  public mutating func clearUser() {self._user = nil}

  public var clients: [ClientEntry] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _user: UserId? = nil
}

public struct NewOtrMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var sender: ClientId {
    get {return _sender ?? ClientId()}
    set {_sender = newValue}
  }
  /// Returns true if `sender` has been explicitly set.
  public var hasSender: Bool {return self._sender != nil}
  /// Clears the value of `sender`. Subsequent reads from it will return its default value.
  public mutating func clearSender() {self._sender = nil}

  public var recipients: [UserEntry] = []

  public var nativePush: Bool {
    get {return _nativePush ?? true}
    set {_nativePush = newValue}
  }
  /// Returns true if `nativePush` has been explicitly set.
  public var hasNativePush: Bool {return self._nativePush != nil}
  /// Clears the value of `nativePush`. Subsequent reads from it will return its default value.
  public mutating func clearNativePush() {self._nativePush = nil}

  public var blob: Data {
    get {return _blob ?? Data()}
    set {_blob = newValue}
  }
  /// Returns true if `blob` has been explicitly set.
  public var hasBlob: Bool {return self._blob != nil}
  /// Clears the value of `blob`. Subsequent reads from it will return its default value.
  public mutating func clearBlob() {self._blob = nil}

  public var nativePriority: NewOtrMessage.Priority {
    get {return _nativePriority ?? .lowPriority}
    set {_nativePriority = newValue}
  }
  /// Returns true if `nativePriority` has been explicitly set.
  public var hasNativePriority: Bool {return self._nativePriority != nil}
  /// Clears the value of `nativePriority`. Subsequent reads from it will return its default value.
  public mutating func clearNativePriority() {self._nativePriority = nil}

  public var transient: Bool {
    get {return _transient ?? false}
    set {_transient = newValue}
  }
  /// Returns true if `transient` has been explicitly set.
  public var hasTransient: Bool {return self._transient != nil}
  /// Clears the value of `transient`. Subsequent reads from it will return its default value.
  public mutating func clearTransient() {self._transient = nil}

  public var reportMissing: [UserId] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Priority: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// 0 is reserved for errors
    case lowPriority // = 1
    case highPriority // = 2

    public init() {
      self = .lowPriority
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 1: self = .lowPriority
      case 2: self = .highPriority
      default: return nil
      }
    }

    public var rawValue: Int {
      switch self {
      case .lowPriority: return 1
      case .highPriority: return 2
      }
    }

  }

  public init() {}

  fileprivate var _sender: ClientId? = nil
  fileprivate var _nativePush: Bool? = nil
  fileprivate var _blob: Data? = nil
  fileprivate var _nativePriority: NewOtrMessage.Priority? = nil
  fileprivate var _transient: Bool? = nil
}

#if swift(>=4.2)

extension NewOtrMessage.Priority: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

public struct OtrAssetMeta {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var sender: ClientId {
    get {return _sender ?? ClientId()}
    set {_sender = newValue}
  }
  /// Returns true if `sender` has been explicitly set.
  public var hasSender: Bool {return self._sender != nil}
  /// Clears the value of `sender`. Subsequent reads from it will return its default value.
  public mutating func clearSender() {self._sender = nil}

  public var recipients: [UserEntry] = []

  public var isInline: Bool {
    get {return _isInline ?? false}
    set {_isInline = newValue}
  }
  /// Returns true if `isInline` has been explicitly set.
  public var hasIsInline: Bool {return self._isInline != nil}
  /// Clears the value of `isInline`. Subsequent reads from it will return its default value.
  public mutating func clearIsInline() {self._isInline = nil}

  public var nativePush: Bool {
    get {return _nativePush ?? true}
    set {_nativePush = newValue}
  }
  /// Returns true if `nativePush` has been explicitly set.
  public var hasNativePush: Bool {return self._nativePush != nil}
  /// Clears the value of `nativePush`. Subsequent reads from it will return its default value.
  public mutating func clearNativePush() {self._nativePush = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _sender: ClientId? = nil
  fileprivate var _isInline: Bool? = nil
  fileprivate var _nativePush: Bool? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension UserId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "UserId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uuid"),
  ]

  public var isInitialized: Bool {
    if self._uuid == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._uuid) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._uuid {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: UserId, rhs: UserId) -> Bool {
    if lhs._uuid != rhs._uuid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ClientId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ClientId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "client"),
  ]

  public var isInitialized: Bool {
    if self._client == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._client) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._client {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ClientId, rhs: ClientId) -> Bool {
    if lhs._client != rhs._client {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ClientEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ClientEntry"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "client"),
    2: .same(proto: "text"),
  ]

  public var isInitialized: Bool {
    if self._client == nil {return false}
    if self._text == nil {return false}
    if let v = self._client, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._client) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._text) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._client {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._text {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ClientEntry, rhs: ClientEntry) -> Bool {
    if lhs._client != rhs._client {return false}
    if lhs._text != rhs._text {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension UserEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "UserEntry"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "user"),
    2: .same(proto: "clients"),
  ]

  public var isInitialized: Bool {
    if self._user == nil {return false}
    if let v = self._user, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.clients) {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._user) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.clients) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._user {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.clients.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.clients, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: UserEntry, rhs: UserEntry) -> Bool {
    if lhs._user != rhs._user {return false}
    if lhs.clients != rhs.clients {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NewOtrMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "NewOtrMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sender"),
    2: .same(proto: "recipients"),
    3: .standard(proto: "native_push"),
    4: .same(proto: "blob"),
    5: .standard(proto: "native_priority"),
    6: .same(proto: "transient"),
    7: .standard(proto: "report_missing"),
  ]

  public var isInitialized: Bool {
    if self._sender == nil {return false}
    if let v = self._sender, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.recipients) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.reportMissing) {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._sender) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.recipients) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._nativePush) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self._blob) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self._nativePriority) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self._transient) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.reportMissing) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._sender {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.recipients.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.recipients, fieldNumber: 2)
    }
    if let v = self._nativePush {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    }
    if let v = self._blob {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 4)
    }
    if let v = self._nativePriority {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 5)
    }
    if let v = self._transient {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
    }
    if !self.reportMissing.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.reportMissing, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: NewOtrMessage, rhs: NewOtrMessage) -> Bool {
    if lhs._sender != rhs._sender {return false}
    if lhs.recipients != rhs.recipients {return false}
    if lhs._nativePush != rhs._nativePush {return false}
    if lhs._blob != rhs._blob {return false}
    if lhs._nativePriority != rhs._nativePriority {return false}
    if lhs._transient != rhs._transient {return false}
    if lhs.reportMissing != rhs.reportMissing {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NewOtrMessage.Priority: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "LOW_PRIORITY"),
    2: .same(proto: "HIGH_PRIORITY"),
  ]
}

extension OtrAssetMeta: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "OtrAssetMeta"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sender"),
    2: .same(proto: "recipients"),
    3: .same(proto: "isInline"),
    4: .standard(proto: "native_push"),
  ]

  public var isInitialized: Bool {
    if self._sender == nil {return false}
    if let v = self._sender, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.recipients) {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._sender) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.recipients) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._isInline) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self._nativePush) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._sender {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.recipients.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.recipients, fieldNumber: 2)
    }
    if let v = self._isInline {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    }
    if let v = self._nativePush {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OtrAssetMeta, rhs: OtrAssetMeta) -> Bool {
    if lhs._sender != rhs._sender {return false}
    if lhs.recipients != rhs.recipients {return false}
    if lhs._isInline != rhs._isInline {return false}
    if lhs._nativePush != rhs._nativePush {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
