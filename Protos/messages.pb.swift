// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: tmp/messages.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum ClientAction: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case resetSession // = 0

  init() {
    self = .resetSession
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .resetSession
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .resetSession: return 0
    }
  }

}

#if swift(>=4.2)

extension ClientAction: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

enum EncryptionAlgorithm: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case aesCbc // = 0
  case aesGcm // = 1

  init() {
    self = .aesCbc
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .aesCbc
    case 1: self = .aesGcm
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .aesCbc: return 0
    case .aesGcm: return 1
    }
  }

}

#if swift(>=4.2)

extension EncryptionAlgorithm: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct GenericMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// client generated random id, preferably UUID
  var messageID: String {
    get {return _storage._messageID ?? String()}
    set {_uniqueStorage()._messageID = newValue}
  }
  /// Returns true if `messageID` has been explicitly set.
  var hasMessageID: Bool {return _storage._messageID != nil}
  /// Clears the value of `messageID`. Subsequent reads from it will return its default value.
  mutating func clearMessageID() {_uniqueStorage()._messageID = nil}

  var content: OneOf_Content? {
    get {return _storage._content}
    set {_uniqueStorage()._content = newValue}
  }

  var text: Text {
    get {
      if case .text(let v)? = _storage._content {return v}
      return Text()
    }
    set {_uniqueStorage()._content = .text(newValue)}
  }

  /// deprecated in favour of Asset
  var image: ImageAsset {
    get {
      if case .image(let v)? = _storage._content {return v}
      return ImageAsset()
    }
    set {_uniqueStorage()._content = .image(newValue)}
  }

  var knock: Knock {
    get {
      if case .knock(let v)? = _storage._content {return v}
      return Knock()
    }
    set {_uniqueStorage()._content = .knock(newValue)}
  }

  var lastRead: LastRead {
    get {
      if case .lastRead(let v)? = _storage._content {return v}
      return LastRead()
    }
    set {_uniqueStorage()._content = .lastRead(newValue)}
  }

  var cleared: Cleared {
    get {
      if case .cleared(let v)? = _storage._content {return v}
      return Cleared()
    }
    set {_uniqueStorage()._content = .cleared(newValue)}
  }

  var external: External {
    get {
      if case .external(let v)? = _storage._content {return v}
      return External()
    }
    set {_uniqueStorage()._content = .external(newValue)}
  }

  var clientAction: ClientAction {
    get {
      if case .clientAction(let v)? = _storage._content {return v}
      return .resetSession
    }
    set {_uniqueStorage()._content = .clientAction(newValue)}
  }

  var calling: Calling {
    get {
      if case .calling(let v)? = _storage._content {return v}
      return Calling()
    }
    set {_uniqueStorage()._content = .calling(newValue)}
  }

  var asset: Asset {
    get {
      if case .asset(let v)? = _storage._content {return v}
      return Asset()
    }
    set {_uniqueStorage()._content = .asset(newValue)}
  }

  var hidden: MessageHide {
    get {
      if case .hidden(let v)? = _storage._content {return v}
      return MessageHide()
    }
    set {_uniqueStorage()._content = .hidden(newValue)}
  }

  var location: Location {
    get {
      if case .location(let v)? = _storage._content {return v}
      return Location()
    }
    set {_uniqueStorage()._content = .location(newValue)}
  }

  var deleted: MessageDelete {
    get {
      if case .deleted(let v)? = _storage._content {return v}
      return MessageDelete()
    }
    set {_uniqueStorage()._content = .deleted(newValue)}
  }

  var edited: MessageEdit {
    get {
      if case .edited(let v)? = _storage._content {return v}
      return MessageEdit()
    }
    set {_uniqueStorage()._content = .edited(newValue)}
  }

  var confirmation: Confirmation {
    get {
      if case .confirmation(let v)? = _storage._content {return v}
      return Confirmation()
    }
    set {_uniqueStorage()._content = .confirmation(newValue)}
  }

  var reaction: Reaction {
    get {
      if case .reaction(let v)? = _storage._content {return v}
      return Reaction()
    }
    set {_uniqueStorage()._content = .reaction(newValue)}
  }

  var ephemeral: Ephemeral {
    get {
      if case .ephemeral(let v)? = _storage._content {return v}
      return Ephemeral()
    }
    set {_uniqueStorage()._content = .ephemeral(newValue)}
  }

  var availability: Availability {
    get {
      if case .availability(let v)? = _storage._content {return v}
      return Availability()
    }
    set {_uniqueStorage()._content = .availability(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Content: Equatable {
    case text(Text)
    /// deprecated in favour of Asset
    case image(ImageAsset)
    case knock(Knock)
    case lastRead(LastRead)
    case cleared(Cleared)
    case external(External)
    case clientAction(ClientAction)
    case calling(Calling)
    case asset(Asset)
    case hidden(MessageHide)
    case location(Location)
    case deleted(MessageDelete)
    case edited(MessageEdit)
    case confirmation(Confirmation)
    case reaction(Reaction)
    case ephemeral(Ephemeral)
    case availability(Availability)

  #if !swift(>=4.1)
    static func ==(lhs: GenericMessage.OneOf_Content, rhs: GenericMessage.OneOf_Content) -> Bool {
      switch (lhs, rhs) {
      case (.text(let l), .text(let r)): return l == r
      case (.image(let l), .image(let r)): return l == r
      case (.knock(let l), .knock(let r)): return l == r
      case (.lastRead(let l), .lastRead(let r)): return l == r
      case (.cleared(let l), .cleared(let r)): return l == r
      case (.external(let l), .external(let r)): return l == r
      case (.clientAction(let l), .clientAction(let r)): return l == r
      case (.calling(let l), .calling(let r)): return l == r
      case (.asset(let l), .asset(let r)): return l == r
      case (.hidden(let l), .hidden(let r)): return l == r
      case (.location(let l), .location(let r)): return l == r
      case (.deleted(let l), .deleted(let r)): return l == r
      case (.edited(let l), .edited(let r)): return l == r
      case (.confirmation(let l), .confirmation(let r)): return l == r
      case (.reaction(let l), .reaction(let r)): return l == r
      case (.ephemeral(let l), .ephemeral(let r)): return l == r
      case (.availability(let l), .availability(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Availability {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: Availability.TypeEnum {
    get {return _type ?? .none}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {self._type = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum TypeEnum: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case none // = 0
    case available // = 1
    case away // = 2
    case busy // = 3

    init() {
      self = .none
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .none
      case 1: self = .available
      case 2: self = .away
      case 3: self = .busy
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .none: return 0
      case .available: return 1
      case .away: return 2
      case .busy: return 3
      }
    }

  }

  init() {}

  fileprivate var _type: Availability.TypeEnum? = nil
}

#if swift(>=4.2)

extension Availability.TypeEnum: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct Ephemeral {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var expireAfterMillis: Int64 {
    get {return _storage._expireAfterMillis ?? 0}
    set {_uniqueStorage()._expireAfterMillis = newValue}
  }
  /// Returns true if `expireAfterMillis` has been explicitly set.
  var hasExpireAfterMillis: Bool {return _storage._expireAfterMillis != nil}
  /// Clears the value of `expireAfterMillis`. Subsequent reads from it will return its default value.
  mutating func clearExpireAfterMillis() {_uniqueStorage()._expireAfterMillis = nil}

  var content: OneOf_Content? {
    get {return _storage._content}
    set {_uniqueStorage()._content = newValue}
  }

  var text: Text {
    get {
      if case .text(let v)? = _storage._content {return v}
      return Text()
    }
    set {_uniqueStorage()._content = .text(newValue)}
  }

  var image: ImageAsset {
    get {
      if case .image(let v)? = _storage._content {return v}
      return ImageAsset()
    }
    set {_uniqueStorage()._content = .image(newValue)}
  }

  var knock: Knock {
    get {
      if case .knock(let v)? = _storage._content {return v}
      return Knock()
    }
    set {_uniqueStorage()._content = .knock(newValue)}
  }

  var asset: Asset {
    get {
      if case .asset(let v)? = _storage._content {return v}
      return Asset()
    }
    set {_uniqueStorage()._content = .asset(newValue)}
  }

  var location: Location {
    get {
      if case .location(let v)? = _storage._content {return v}
      return Location()
    }
    set {_uniqueStorage()._content = .location(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Content: Equatable {
    case text(Text)
    case image(ImageAsset)
    case knock(Knock)
    case asset(Asset)
    case location(Location)

  #if !swift(>=4.1)
    static func ==(lhs: Ephemeral.OneOf_Content, rhs: Ephemeral.OneOf_Content) -> Bool {
      switch (lhs, rhs) {
      case (.text(let l), .text(let r)): return l == r
      case (.image(let l), .image(let r)): return l == r
      case (.knock(let l), .knock(let r)): return l == r
      case (.asset(let l), .asset(let r)): return l == r
      case (.location(let l), .location(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Text {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var content: String {
    get {return _storage._content ?? String()}
    set {_uniqueStorage()._content = newValue}
  }
  /// Returns true if `content` has been explicitly set.
  var hasContent: Bool {return _storage._content != nil}
  /// Clears the value of `content`. Subsequent reads from it will return its default value.
  mutating func clearContent() {_uniqueStorage()._content = nil}

  /// reserved 2; // reserved keyword is not available in older protoc versions
  var linkPreview: [LinkPreview] {
    get {return _storage._linkPreview}
    set {_uniqueStorage()._linkPreview = newValue}
  }

  var mentions: [Mention] {
    get {return _storage._mentions}
    set {_uniqueStorage()._mentions = newValue}
  }

  /// if this Text is part of a MessageEdit, this field is ignored
  var quote: Quote {
    get {return _storage._quote ?? Quote()}
    set {_uniqueStorage()._quote = newValue}
  }
  /// Returns true if `quote` has been explicitly set.
  var hasQuote: Bool {return _storage._quote != nil}
  /// Clears the value of `quote`. Subsequent reads from it will return its default value.
  mutating func clearQuote() {_uniqueStorage()._quote = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Knock {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var hotKnock: Bool {
    get {return _hotKnock ?? false}
    set {_hotKnock = newValue}
  }
  /// Returns true if `hotKnock` has been explicitly set.
  var hasHotKnock: Bool {return self._hotKnock != nil}
  /// Clears the value of `hotKnock`. Subsequent reads from it will return its default value.
  mutating func clearHotKnock() {self._hotKnock = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _hotKnock: Bool? = nil
}

struct LinkPreview {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var url: String {
    get {return _storage._url ?? String()}
    set {_uniqueStorage()._url = newValue}
  }
  /// Returns true if `url` has been explicitly set.
  var hasURL: Bool {return _storage._url != nil}
  /// Clears the value of `url`. Subsequent reads from it will return its default value.
  mutating func clearURL() {_uniqueStorage()._url = nil}

  /// url offset from beginning of text message
  var urlOffset: Int32 {
    get {return _storage._urlOffset ?? 0}
    set {_uniqueStorage()._urlOffset = newValue}
  }
  /// Returns true if `urlOffset` has been explicitly set.
  var hasURLOffset: Bool {return _storage._urlOffset != nil}
  /// Clears the value of `urlOffset`. Subsequent reads from it will return its default value.
  mutating func clearURLOffset() {_uniqueStorage()._urlOffset = nil}

  var preview: OneOf_Preview? {
    get {return _storage._preview}
    set {_uniqueStorage()._preview = newValue}
  }

  /// deprecated - use meta_data
  var article: Article {
    get {
      if case .article(let v)? = _storage._preview {return v}
      return Article()
    }
    set {_uniqueStorage()._preview = .article(newValue)}
  }

  var permanentURL: String {
    get {return _storage._permanentURL ?? String()}
    set {_uniqueStorage()._permanentURL = newValue}
  }
  /// Returns true if `permanentURL` has been explicitly set.
  var hasPermanentURL: Bool {return _storage._permanentURL != nil}
  /// Clears the value of `permanentURL`. Subsequent reads from it will return its default value.
  mutating func clearPermanentURL() {_uniqueStorage()._permanentURL = nil}

  var title: String {
    get {return _storage._title ?? String()}
    set {_uniqueStorage()._title = newValue}
  }
  /// Returns true if `title` has been explicitly set.
  var hasTitle: Bool {return _storage._title != nil}
  /// Clears the value of `title`. Subsequent reads from it will return its default value.
  mutating func clearTitle() {_uniqueStorage()._title = nil}

  var summary: String {
    get {return _storage._summary ?? String()}
    set {_uniqueStorage()._summary = newValue}
  }
  /// Returns true if `summary` has been explicitly set.
  var hasSummary: Bool {return _storage._summary != nil}
  /// Clears the value of `summary`. Subsequent reads from it will return its default value.
  mutating func clearSummary() {_uniqueStorage()._summary = nil}

  var image: Asset {
    get {return _storage._image ?? Asset()}
    set {_uniqueStorage()._image = newValue}
  }
  /// Returns true if `image` has been explicitly set.
  var hasImage: Bool {return _storage._image != nil}
  /// Clears the value of `image`. Subsequent reads from it will return its default value.
  mutating func clearImage() {_uniqueStorage()._image = nil}

  var metaData: OneOf_MetaData? {
    get {return _storage._metaData}
    set {_uniqueStorage()._metaData = newValue}
  }

  var tweet: Tweet {
    get {
      if case .tweet(let v)? = _storage._metaData {return v}
      return Tweet()
    }
    set {_uniqueStorage()._metaData = .tweet(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Preview: Equatable {
    /// deprecated - use meta_data
    case article(Article)

  #if !swift(>=4.1)
    static func ==(lhs: LinkPreview.OneOf_Preview, rhs: LinkPreview.OneOf_Preview) -> Bool {
      switch (lhs, rhs) {
      case (.article(let l), .article(let r)): return l == r
      }
    }
  #endif
  }

  enum OneOf_MetaData: Equatable {
    case tweet(Tweet)

  #if !swift(>=4.1)
    static func ==(lhs: LinkPreview.OneOf_MetaData, rhs: LinkPreview.OneOf_MetaData) -> Bool {
      switch (lhs, rhs) {
      case (.tweet(let l), .tweet(let r)): return l == r
      }
    }
  #endif
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Tweet {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var author: String {
    get {return _author ?? String()}
    set {_author = newValue}
  }
  /// Returns true if `author` has been explicitly set.
  var hasAuthor: Bool {return self._author != nil}
  /// Clears the value of `author`. Subsequent reads from it will return its default value.
  mutating func clearAuthor() {self._author = nil}

  var username: String {
    get {return _username ?? String()}
    set {_username = newValue}
  }
  /// Returns true if `username` has been explicitly set.
  var hasUsername: Bool {return self._username != nil}
  /// Clears the value of `username`. Subsequent reads from it will return its default value.
  mutating func clearUsername() {self._username = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _author: String? = nil
  fileprivate var _username: String? = nil
}

/// deprecated - use the additional fields in LinkPreview
struct Article {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var permanentURL: String {
    get {return _storage._permanentURL ?? String()}
    set {_uniqueStorage()._permanentURL = newValue}
  }
  /// Returns true if `permanentURL` has been explicitly set.
  var hasPermanentURL: Bool {return _storage._permanentURL != nil}
  /// Clears the value of `permanentURL`. Subsequent reads from it will return its default value.
  mutating func clearPermanentURL() {_uniqueStorage()._permanentURL = nil}

  var title: String {
    get {return _storage._title ?? String()}
    set {_uniqueStorage()._title = newValue}
  }
  /// Returns true if `title` has been explicitly set.
  var hasTitle: Bool {return _storage._title != nil}
  /// Clears the value of `title`. Subsequent reads from it will return its default value.
  mutating func clearTitle() {_uniqueStorage()._title = nil}

  var summary: String {
    get {return _storage._summary ?? String()}
    set {_uniqueStorage()._summary = newValue}
  }
  /// Returns true if `summary` has been explicitly set.
  var hasSummary: Bool {return _storage._summary != nil}
  /// Clears the value of `summary`. Subsequent reads from it will return its default value.
  mutating func clearSummary() {_uniqueStorage()._summary = nil}

  var image: Asset {
    get {return _storage._image ?? Asset()}
    set {_uniqueStorage()._image = newValue}
  }
  /// Returns true if `image` has been explicitly set.
  var hasImage: Bool {return _storage._image != nil}
  /// Clears the value of `image`. Subsequent reads from it will return its default value.
  mutating func clearImage() {_uniqueStorage()._image = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Mention {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// offset from beginning of the message counting in utf16 characters
  var start: Int32 {
    get {return _start ?? 0}
    set {_start = newValue}
  }
  /// Returns true if `start` has been explicitly set.
  var hasStart: Bool {return self._start != nil}
  /// Clears the value of `start`. Subsequent reads from it will return its default value.
  mutating func clearStart() {self._start = nil}

  var length: Int32 {
    get {return _length ?? 0}
    set {_length = newValue}
  }
  /// Returns true if `length` has been explicitly set.
  var hasLength: Bool {return self._length != nil}
  /// Clears the value of `length`. Subsequent reads from it will return its default value.
  mutating func clearLength() {self._length = nil}

  var mentionType: Mention.OneOf_MentionType? = nil

  var userID: String {
    get {
      if case .userID(let v)? = mentionType {return v}
      return String()
    }
    set {mentionType = .userID(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_MentionType: Equatable {
    case userID(String)

  #if !swift(>=4.1)
    static func ==(lhs: Mention.OneOf_MentionType, rhs: Mention.OneOf_MentionType) -> Bool {
      switch (lhs, rhs) {
      case (.userID(let l), .userID(let r)): return l == r
      }
    }
  #endif
  }

  init() {}

  fileprivate var _start: Int32? = nil
  fileprivate var _length: Int32? = nil
}

struct LastRead {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var conversationID: String {
    get {return _conversationID ?? String()}
    set {_conversationID = newValue}
  }
  /// Returns true if `conversationID` has been explicitly set.
  var hasConversationID: Bool {return self._conversationID != nil}
  /// Clears the value of `conversationID`. Subsequent reads from it will return its default value.
  mutating func clearConversationID() {self._conversationID = nil}

  var lastReadTimestamp: Int64 {
    get {return _lastReadTimestamp ?? 0}
    set {_lastReadTimestamp = newValue}
  }
  /// Returns true if `lastReadTimestamp` has been explicitly set.
  var hasLastReadTimestamp: Bool {return self._lastReadTimestamp != nil}
  /// Clears the value of `lastReadTimestamp`. Subsequent reads from it will return its default value.
  mutating func clearLastReadTimestamp() {self._lastReadTimestamp = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _conversationID: String? = nil
  fileprivate var _lastReadTimestamp: Int64? = nil
}

struct Cleared {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var conversationID: String {
    get {return _conversationID ?? String()}
    set {_conversationID = newValue}
  }
  /// Returns true if `conversationID` has been explicitly set.
  var hasConversationID: Bool {return self._conversationID != nil}
  /// Clears the value of `conversationID`. Subsequent reads from it will return its default value.
  mutating func clearConversationID() {self._conversationID = nil}

  var clearedTimestamp: Int64 {
    get {return _clearedTimestamp ?? 0}
    set {_clearedTimestamp = newValue}
  }
  /// Returns true if `clearedTimestamp` has been explicitly set.
  var hasClearedTimestamp: Bool {return self._clearedTimestamp != nil}
  /// Clears the value of `clearedTimestamp`. Subsequent reads from it will return its default value.
  mutating func clearClearedTimestamp() {self._clearedTimestamp = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _conversationID: String? = nil
  fileprivate var _clearedTimestamp: Int64? = nil
}

struct MessageHide {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var conversationID: String {
    get {return _conversationID ?? String()}
    set {_conversationID = newValue}
  }
  /// Returns true if `conversationID` has been explicitly set.
  var hasConversationID: Bool {return self._conversationID != nil}
  /// Clears the value of `conversationID`. Subsequent reads from it will return its default value.
  mutating func clearConversationID() {self._conversationID = nil}

  var messageID: String {
    get {return _messageID ?? String()}
    set {_messageID = newValue}
  }
  /// Returns true if `messageID` has been explicitly set.
  var hasMessageID: Bool {return self._messageID != nil}
  /// Clears the value of `messageID`. Subsequent reads from it will return its default value.
  mutating func clearMessageID() {self._messageID = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _conversationID: String? = nil
  fileprivate var _messageID: String? = nil
}

struct MessageDelete {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var messageID: String {
    get {return _messageID ?? String()}
    set {_messageID = newValue}
  }
  /// Returns true if `messageID` has been explicitly set.
  var hasMessageID: Bool {return self._messageID != nil}
  /// Clears the value of `messageID`. Subsequent reads from it will return its default value.
  mutating func clearMessageID() {self._messageID = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _messageID: String? = nil
}

struct MessageEdit {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var replacingMessageID: String {
    get {return _storage._replacingMessageID ?? String()}
    set {_uniqueStorage()._replacingMessageID = newValue}
  }
  /// Returns true if `replacingMessageID` has been explicitly set.
  var hasReplacingMessageID: Bool {return _storage._replacingMessageID != nil}
  /// Clears the value of `replacingMessageID`. Subsequent reads from it will return its default value.
  mutating func clearReplacingMessageID() {_uniqueStorage()._replacingMessageID = nil}

  var content: OneOf_Content? {
    get {return _storage._content}
    set {_uniqueStorage()._content = newValue}
  }

  /// Reply can also be edited, but the edit will only affect the Text part
  var text: Text {
    get {
      if case .text(let v)? = _storage._content {return v}
      return Text()
    }
    set {_uniqueStorage()._content = .text(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Content: Equatable {
    /// Reply can also be edited, but the edit will only affect the Text part
    case text(Text)

  #if !swift(>=4.1)
    static func ==(lhs: MessageEdit.OneOf_Content, rhs: MessageEdit.OneOf_Content) -> Bool {
      switch (lhs, rhs) {
      case (.text(let l), .text(let r)): return l == r
      }
    }
  #endif
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Quote {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var quotedMessageID: String {
    get {return _quotedMessageID ?? String()}
    set {_quotedMessageID = newValue}
  }
  /// Returns true if `quotedMessageID` has been explicitly set.
  var hasQuotedMessageID: Bool {return self._quotedMessageID != nil}
  /// Clears the value of `quotedMessageID`. Subsequent reads from it will return its default value.
  mutating func clearQuotedMessageID() {self._quotedMessageID = nil}

  var quotedMessageSha256: Data {
    get {return _quotedMessageSha256 ?? SwiftProtobuf.Internal.emptyData}
    set {_quotedMessageSha256 = newValue}
  }
  /// Returns true if `quotedMessageSha256` has been explicitly set.
  var hasQuotedMessageSha256: Bool {return self._quotedMessageSha256 != nil}
  /// Clears the value of `quotedMessageSha256`. Subsequent reads from it will return its default value.
  mutating func clearQuotedMessageSha256() {self._quotedMessageSha256 = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _quotedMessageID: String? = nil
  fileprivate var _quotedMessageSha256: Data? = nil
}

struct Confirmation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: Confirmation.TypeEnum {
    get {return _type ?? .delivered}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {self._type = nil}

  var firstMessageID: String {
    get {return _firstMessageID ?? String()}
    set {_firstMessageID = newValue}
  }
  /// Returns true if `firstMessageID` has been explicitly set.
  var hasFirstMessageID: Bool {return self._firstMessageID != nil}
  /// Clears the value of `firstMessageID`. Subsequent reads from it will return its default value.
  mutating func clearFirstMessageID() {self._firstMessageID = nil}

  var moreMessageIds: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum TypeEnum: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case delivered // = 0
    case read // = 1

    init() {
      self = .delivered
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .delivered
      case 1: self = .read
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .delivered: return 0
      case .read: return 1
      }
    }

  }

  init() {}

  fileprivate var _type: Confirmation.TypeEnum? = nil
  fileprivate var _firstMessageID: String? = nil
}

#if swift(>=4.2)

extension Confirmation.TypeEnum: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct Location {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var longitude: Float {
    get {return _longitude ?? 0}
    set {_longitude = newValue}
  }
  /// Returns true if `longitude` has been explicitly set.
  var hasLongitude: Bool {return self._longitude != nil}
  /// Clears the value of `longitude`. Subsequent reads from it will return its default value.
  mutating func clearLongitude() {self._longitude = nil}

  var latitude: Float {
    get {return _latitude ?? 0}
    set {_latitude = newValue}
  }
  /// Returns true if `latitude` has been explicitly set.
  var hasLatitude: Bool {return self._latitude != nil}
  /// Clears the value of `latitude`. Subsequent reads from it will return its default value.
  mutating func clearLatitude() {self._latitude = nil}

  /// location description/name
  var name: String {
    get {return _name ?? String()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  mutating func clearName() {self._name = nil}

  /// google maps zoom level (check maps api documentation)
  var zoom: Int32 {
    get {return _zoom ?? 0}
    set {_zoom = newValue}
  }
  /// Returns true if `zoom` has been explicitly set.
  var hasZoom: Bool {return self._zoom != nil}
  /// Clears the value of `zoom`. Subsequent reads from it will return its default value.
  mutating func clearZoom() {self._zoom = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _longitude: Float? = nil
  fileprivate var _latitude: Float? = nil
  fileprivate var _name: String? = nil
  fileprivate var _zoom: Int32? = nil
}

/// deprecated in favour of Asset.Original.ImageMetaData
struct ImageAsset {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var tag: String {
    get {return _tag ?? String()}
    set {_tag = newValue}
  }
  /// Returns true if `tag` has been explicitly set.
  var hasTag: Bool {return self._tag != nil}
  /// Clears the value of `tag`. Subsequent reads from it will return its default value.
  mutating func clearTag() {self._tag = nil}

  var width: Int32 {
    get {return _width ?? 0}
    set {_width = newValue}
  }
  /// Returns true if `width` has been explicitly set.
  var hasWidth: Bool {return self._width != nil}
  /// Clears the value of `width`. Subsequent reads from it will return its default value.
  mutating func clearWidth() {self._width = nil}

  var height: Int32 {
    get {return _height ?? 0}
    set {_height = newValue}
  }
  /// Returns true if `height` has been explicitly set.
  var hasHeight: Bool {return self._height != nil}
  /// Clears the value of `height`. Subsequent reads from it will return its default value.
  mutating func clearHeight() {self._height = nil}

  var originalWidth: Int32 {
    get {return _originalWidth ?? 0}
    set {_originalWidth = newValue}
  }
  /// Returns true if `originalWidth` has been explicitly set.
  var hasOriginalWidth: Bool {return self._originalWidth != nil}
  /// Clears the value of `originalWidth`. Subsequent reads from it will return its default value.
  mutating func clearOriginalWidth() {self._originalWidth = nil}

  var originalHeight: Int32 {
    get {return _originalHeight ?? 0}
    set {_originalHeight = newValue}
  }
  /// Returns true if `originalHeight` has been explicitly set.
  var hasOriginalHeight: Bool {return self._originalHeight != nil}
  /// Clears the value of `originalHeight`. Subsequent reads from it will return its default value.
  mutating func clearOriginalHeight() {self._originalHeight = nil}

  var mimeType: String {
    get {return _mimeType ?? String()}
    set {_mimeType = newValue}
  }
  /// Returns true if `mimeType` has been explicitly set.
  var hasMimeType: Bool {return self._mimeType != nil}
  /// Clears the value of `mimeType`. Subsequent reads from it will return its default value.
  mutating func clearMimeType() {self._mimeType = nil}

  var size: Int32 {
    get {return _size ?? 0}
    set {_size = newValue}
  }
  /// Returns true if `size` has been explicitly set.
  var hasSize: Bool {return self._size != nil}
  /// Clears the value of `size`. Subsequent reads from it will return its default value.
  mutating func clearSize() {self._size = nil}

  var otrKey: Data {
    get {return _otrKey ?? SwiftProtobuf.Internal.emptyData}
    set {_otrKey = newValue}
  }
  /// Returns true if `otrKey` has been explicitly set.
  var hasOtrKey: Bool {return self._otrKey != nil}
  /// Clears the value of `otrKey`. Subsequent reads from it will return its default value.
  mutating func clearOtrKey() {self._otrKey = nil}

  /// deprecated - use sha256
  var macKey: Data {
    get {return _macKey ?? SwiftProtobuf.Internal.emptyData}
    set {_macKey = newValue}
  }
  /// Returns true if `macKey` has been explicitly set.
  var hasMacKey: Bool {return self._macKey != nil}
  /// Clears the value of `macKey`. Subsequent reads from it will return its default value.
  mutating func clearMacKey() {self._macKey = nil}

  /// deprecated - use sha256
  var mac: Data {
    get {return _mac ?? SwiftProtobuf.Internal.emptyData}
    set {_mac = newValue}
  }
  /// Returns true if `mac` has been explicitly set.
  var hasMac: Bool {return self._mac != nil}
  /// Clears the value of `mac`. Subsequent reads from it will return its default value.
  mutating func clearMac() {self._mac = nil}

  /// sha256 of ciphertext
  var sha256: Data {
    get {return _sha256 ?? SwiftProtobuf.Internal.emptyData}
    set {_sha256 = newValue}
  }
  /// Returns true if `sha256` has been explicitly set.
  var hasSha256: Bool {return self._sha256 != nil}
  /// Clears the value of `sha256`. Subsequent reads from it will return its default value.
  mutating func clearSha256() {self._sha256 = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _tag: String? = nil
  fileprivate var _width: Int32? = nil
  fileprivate var _height: Int32? = nil
  fileprivate var _originalWidth: Int32? = nil
  fileprivate var _originalHeight: Int32? = nil
  fileprivate var _mimeType: String? = nil
  fileprivate var _size: Int32? = nil
  fileprivate var _otrKey: Data? = nil
  fileprivate var _macKey: Data? = nil
  fileprivate var _mac: Data? = nil
  fileprivate var _sha256: Data? = nil
}

struct Asset {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var original: Asset.Original {
    get {return _storage._original ?? Asset.Original()}
    set {_uniqueStorage()._original = newValue}
  }
  /// Returns true if `original` has been explicitly set.
  var hasOriginal: Bool {return _storage._original != nil}
  /// Clears the value of `original`. Subsequent reads from it will return its default value.
  mutating func clearOriginal() {_uniqueStorage()._original = nil}

  ///  optional Preview preview = 2;  // deprecated - preview was completely replaced
  var status: OneOf_Status? {
    get {return _storage._status}
    set {_uniqueStorage()._status = newValue}
  }

  var notUploaded: Asset.NotUploaded {
    get {
      if case .notUploaded(let v)? = _storage._status {return v}
      return .cancelled
    }
    set {_uniqueStorage()._status = .notUploaded(newValue)}
  }

  var uploaded: Asset.RemoteData {
    get {
      if case .uploaded(let v)? = _storage._status {return v}
      return Asset.RemoteData()
    }
    set {_uniqueStorage()._status = .uploaded(newValue)}
  }

  var preview: Asset.Preview {
    get {return _storage._preview ?? Asset.Preview()}
    set {_uniqueStorage()._preview = newValue}
  }
  /// Returns true if `preview` has been explicitly set.
  var hasPreview: Bool {return _storage._preview != nil}
  /// Clears the value of `preview`. Subsequent reads from it will return its default value.
  mutating func clearPreview() {_uniqueStorage()._preview = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  ///  optional Preview preview = 2;  // deprecated - preview was completely replaced
  enum OneOf_Status: Equatable {
    case notUploaded(Asset.NotUploaded)
    case uploaded(Asset.RemoteData)

  #if !swift(>=4.1)
    static func ==(lhs: Asset.OneOf_Status, rhs: Asset.OneOf_Status) -> Bool {
      switch (lhs, rhs) {
      case (.notUploaded(let l), .notUploaded(let r)): return l == r
      case (.uploaded(let l), .uploaded(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  enum NotUploaded: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case cancelled // = 0
    case failed // = 1

    init() {
      self = .cancelled
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .cancelled
      case 1: self = .failed
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .cancelled: return 0
      case .failed: return 1
      }
    }

  }

  struct Original {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var mimeType: String {
      get {return _storage._mimeType ?? String()}
      set {_uniqueStorage()._mimeType = newValue}
    }
    /// Returns true if `mimeType` has been explicitly set.
    var hasMimeType: Bool {return _storage._mimeType != nil}
    /// Clears the value of `mimeType`. Subsequent reads from it will return its default value.
    mutating func clearMimeType() {_uniqueStorage()._mimeType = nil}

    var size: UInt64 {
      get {return _storage._size ?? 0}
      set {_uniqueStorage()._size = newValue}
    }
    /// Returns true if `size` has been explicitly set.
    var hasSize: Bool {return _storage._size != nil}
    /// Clears the value of `size`. Subsequent reads from it will return its default value.
    mutating func clearSize() {_uniqueStorage()._size = nil}

    var name: String {
      get {return _storage._name ?? String()}
      set {_uniqueStorage()._name = newValue}
    }
    /// Returns true if `name` has been explicitly set.
    var hasName: Bool {return _storage._name != nil}
    /// Clears the value of `name`. Subsequent reads from it will return its default value.
    mutating func clearName() {_uniqueStorage()._name = nil}

    var metaData: OneOf_MetaData? {
      get {return _storage._metaData}
      set {_uniqueStorage()._metaData = newValue}
    }

    var image: Asset.ImageMetaData {
      get {
        if case .image(let v)? = _storage._metaData {return v}
        return Asset.ImageMetaData()
      }
      set {_uniqueStorage()._metaData = .image(newValue)}
    }

    var video: Asset.VideoMetaData {
      get {
        if case .video(let v)? = _storage._metaData {return v}
        return Asset.VideoMetaData()
      }
      set {_uniqueStorage()._metaData = .video(newValue)}
    }

    var audio: Asset.AudioMetaData {
      get {
        if case .audio(let v)? = _storage._metaData {return v}
        return Asset.AudioMetaData()
      }
      set {_uniqueStorage()._metaData = .audio(newValue)}
    }

    /// link to source e.g. http://giphy.com/234245
    var source: String {
      get {return _storage._source ?? String()}
      set {_uniqueStorage()._source = newValue}
    }
    /// Returns true if `source` has been explicitly set.
    var hasSource: Bool {return _storage._source != nil}
    /// Clears the value of `source`. Subsequent reads from it will return its default value.
    mutating func clearSource() {_uniqueStorage()._source = nil}

    /// caption of the asset, e.g. "dog" for a Giphy "dog" search result
    var caption: String {
      get {return _storage._caption ?? String()}
      set {_uniqueStorage()._caption = newValue}
    }
    /// Returns true if `caption` has been explicitly set.
    var hasCaption: Bool {return _storage._caption != nil}
    /// Clears the value of `caption`. Subsequent reads from it will return its default value.
    mutating func clearCaption() {_uniqueStorage()._caption = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_MetaData: Equatable {
      case image(Asset.ImageMetaData)
      case video(Asset.VideoMetaData)
      case audio(Asset.AudioMetaData)

    #if !swift(>=4.1)
      static func ==(lhs: Asset.Original.OneOf_MetaData, rhs: Asset.Original.OneOf_MetaData) -> Bool {
        switch (lhs, rhs) {
        case (.image(let l), .image(let r)): return l == r
        case (.video(let l), .video(let r)): return l == r
        case (.audio(let l), .audio(let r)): return l == r
        default: return false
        }
      }
    #endif
    }

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  struct Preview {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var mimeType: String {
      get {return _storage._mimeType ?? String()}
      set {_uniqueStorage()._mimeType = newValue}
    }
    /// Returns true if `mimeType` has been explicitly set.
    var hasMimeType: Bool {return _storage._mimeType != nil}
    /// Clears the value of `mimeType`. Subsequent reads from it will return its default value.
    mutating func clearMimeType() {_uniqueStorage()._mimeType = nil}

    var size: UInt64 {
      get {return _storage._size ?? 0}
      set {_uniqueStorage()._size = newValue}
    }
    /// Returns true if `size` has been explicitly set.
    var hasSize: Bool {return _storage._size != nil}
    /// Clears the value of `size`. Subsequent reads from it will return its default value.
    mutating func clearSize() {_uniqueStorage()._size = nil}

    var remote: Asset.RemoteData {
      get {return _storage._remote ?? Asset.RemoteData()}
      set {_uniqueStorage()._remote = newValue}
    }
    /// Returns true if `remote` has been explicitly set.
    var hasRemote: Bool {return _storage._remote != nil}
    /// Clears the value of `remote`. Subsequent reads from it will return its default value.
    mutating func clearRemote() {_uniqueStorage()._remote = nil}

    var metaData: OneOf_MetaData? {
      get {return _storage._metaData}
      set {_uniqueStorage()._metaData = newValue}
    }

    var image: Asset.ImageMetaData {
      get {
        if case .image(let v)? = _storage._metaData {return v}
        return Asset.ImageMetaData()
      }
      set {_uniqueStorage()._metaData = .image(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_MetaData: Equatable {
      case image(Asset.ImageMetaData)

    #if !swift(>=4.1)
      static func ==(lhs: Asset.Preview.OneOf_MetaData, rhs: Asset.Preview.OneOf_MetaData) -> Bool {
        switch (lhs, rhs) {
        case (.image(let l), .image(let r)): return l == r
        }
      }
    #endif
    }

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  struct ImageMetaData {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var width: Int32 {
      get {return _width ?? 0}
      set {_width = newValue}
    }
    /// Returns true if `width` has been explicitly set.
    var hasWidth: Bool {return self._width != nil}
    /// Clears the value of `width`. Subsequent reads from it will return its default value.
    mutating func clearWidth() {self._width = nil}

    var height: Int32 {
      get {return _height ?? 0}
      set {_height = newValue}
    }
    /// Returns true if `height` has been explicitly set.
    var hasHeight: Bool {return self._height != nil}
    /// Clears the value of `height`. Subsequent reads from it will return its default value.
    mutating func clearHeight() {self._height = nil}

    var tag: String {
      get {return _tag ?? String()}
      set {_tag = newValue}
    }
    /// Returns true if `tag` has been explicitly set.
    var hasTag: Bool {return self._tag != nil}
    /// Clears the value of `tag`. Subsequent reads from it will return its default value.
    mutating func clearTag() {self._tag = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _width: Int32? = nil
    fileprivate var _height: Int32? = nil
    fileprivate var _tag: String? = nil
  }

  struct VideoMetaData {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var width: Int32 {
      get {return _width ?? 0}
      set {_width = newValue}
    }
    /// Returns true if `width` has been explicitly set.
    var hasWidth: Bool {return self._width != nil}
    /// Clears the value of `width`. Subsequent reads from it will return its default value.
    mutating func clearWidth() {self._width = nil}

    var height: Int32 {
      get {return _height ?? 0}
      set {_height = newValue}
    }
    /// Returns true if `height` has been explicitly set.
    var hasHeight: Bool {return self._height != nil}
    /// Clears the value of `height`. Subsequent reads from it will return its default value.
    mutating func clearHeight() {self._height = nil}

    var durationInMillis: UInt64 {
      get {return _durationInMillis ?? 0}
      set {_durationInMillis = newValue}
    }
    /// Returns true if `durationInMillis` has been explicitly set.
    var hasDurationInMillis: Bool {return self._durationInMillis != nil}
    /// Clears the value of `durationInMillis`. Subsequent reads from it will return its default value.
    mutating func clearDurationInMillis() {self._durationInMillis = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _width: Int32? = nil
    fileprivate var _height: Int32? = nil
    fileprivate var _durationInMillis: UInt64? = nil
  }

  struct AudioMetaData {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var durationInMillis: UInt64 {
      get {return _durationInMillis ?? 0}
      set {_durationInMillis = newValue}
    }
    /// Returns true if `durationInMillis` has been explicitly set.
    var hasDurationInMillis: Bool {return self._durationInMillis != nil}
    /// Clears the value of `durationInMillis`. Subsequent reads from it will return its default value.
    mutating func clearDurationInMillis() {self._durationInMillis = nil}

    /// repeated float normalized_loudness = 2 [packed=true]; // deprecated - Switched to bytes instead
    var normalizedLoudness: Data {
      get {return _normalizedLoudness ?? SwiftProtobuf.Internal.emptyData}
      set {_normalizedLoudness = newValue}
    }
    /// Returns true if `normalizedLoudness` has been explicitly set.
    var hasNormalizedLoudness: Bool {return self._normalizedLoudness != nil}
    /// Clears the value of `normalizedLoudness`. Subsequent reads from it will return its default value.
    mutating func clearNormalizedLoudness() {self._normalizedLoudness = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _durationInMillis: UInt64? = nil
    fileprivate var _normalizedLoudness: Data? = nil
  }

  struct RemoteData {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var otrKey: Data {
      get {return _otrKey ?? SwiftProtobuf.Internal.emptyData}
      set {_otrKey = newValue}
    }
    /// Returns true if `otrKey` has been explicitly set.
    var hasOtrKey: Bool {return self._otrKey != nil}
    /// Clears the value of `otrKey`. Subsequent reads from it will return its default value.
    mutating func clearOtrKey() {self._otrKey = nil}

    /// obsolete but required for backward compatibility
    var sha256: Data {
      get {return _sha256 ?? SwiftProtobuf.Internal.emptyData}
      set {_sha256 = newValue}
    }
    /// Returns true if `sha256` has been explicitly set.
    var hasSha256: Bool {return self._sha256 != nil}
    /// Clears the value of `sha256`. Subsequent reads from it will return its default value.
    mutating func clearSha256() {self._sha256 = nil}

    var assetID: String {
      get {return _assetID ?? String()}
      set {_assetID = newValue}
    }
    /// Returns true if `assetID` has been explicitly set.
    var hasAssetID: Bool {return self._assetID != nil}
    /// Clears the value of `assetID`. Subsequent reads from it will return its default value.
    mutating func clearAssetID() {self._assetID = nil}

    ///    optional bytes asset_token = 4; // deprecated - changed type to string
    var assetToken: String {
      get {return _assetToken ?? String()}
      set {_assetToken = newValue}
    }
    /// Returns true if `assetToken` has been explicitly set.
    var hasAssetToken: Bool {return self._assetToken != nil}
    /// Clears the value of `assetToken`. Subsequent reads from it will return its default value.
    mutating func clearAssetToken() {self._assetToken = nil}

    var encryption: EncryptionAlgorithm {
      get {return _encryption ?? .aesCbc}
      set {_encryption = newValue}
    }
    /// Returns true if `encryption` has been explicitly set.
    var hasEncryption: Bool {return self._encryption != nil}
    /// Clears the value of `encryption`. Subsequent reads from it will return its default value.
    mutating func clearEncryption() {self._encryption = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _otrKey: Data? = nil
    fileprivate var _sha256: Data? = nil
    fileprivate var _assetID: String? = nil
    fileprivate var _assetToken: String? = nil
    fileprivate var _encryption: EncryptionAlgorithm? = nil
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Asset.NotUploaded: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

/// Actual message is encrypted with AES and sent as additional data
struct External {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var otrKey: Data {
    get {return _otrKey ?? SwiftProtobuf.Internal.emptyData}
    set {_otrKey = newValue}
  }
  /// Returns true if `otrKey` has been explicitly set.
  var hasOtrKey: Bool {return self._otrKey != nil}
  /// Clears the value of `otrKey`. Subsequent reads from it will return its default value.
  mutating func clearOtrKey() {self._otrKey = nil}

  /// sha256 of ciphertext, obsolete but required for backward compatibility
  var sha256: Data {
    get {return _sha256 ?? SwiftProtobuf.Internal.emptyData}
    set {_sha256 = newValue}
  }
  /// Returns true if `sha256` has been explicitly set.
  var hasSha256: Bool {return self._sha256 != nil}
  /// Clears the value of `sha256`. Subsequent reads from it will return its default value.
  mutating func clearSha256() {self._sha256 = nil}

  var encryption: EncryptionAlgorithm {
    get {return _encryption ?? .aesCbc}
    set {_encryption = newValue}
  }
  /// Returns true if `encryption` has been explicitly set.
  var hasEncryption: Bool {return self._encryption != nil}
  /// Clears the value of `encryption`. Subsequent reads from it will return its default value.
  mutating func clearEncryption() {self._encryption = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _otrKey: Data? = nil
  fileprivate var _sha256: Data? = nil
  fileprivate var _encryption: EncryptionAlgorithm? = nil
}

struct Reaction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// some emoji reaction or the empty string to remove previous reaction(s)
  var emoji: String {
    get {return _emoji ?? String()}
    set {_emoji = newValue}
  }
  /// Returns true if `emoji` has been explicitly set.
  var hasEmoji: Bool {return self._emoji != nil}
  /// Clears the value of `emoji`. Subsequent reads from it will return its default value.
  mutating func clearEmoji() {self._emoji = nil}

  var messageID: String {
    get {return _messageID ?? String()}
    set {_messageID = newValue}
  }
  /// Returns true if `messageID` has been explicitly set.
  var hasMessageID: Bool {return self._messageID != nil}
  /// Clears the value of `messageID`. Subsequent reads from it will return its default value.
  mutating func clearMessageID() {self._messageID = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _emoji: String? = nil
  fileprivate var _messageID: String? = nil
}

struct Calling {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var content: String {
    get {return _content ?? String()}
    set {_content = newValue}
  }
  /// Returns true if `content` has been explicitly set.
  var hasContent: Bool {return self._content != nil}
  /// Clears the value of `content`. Subsequent reads from it will return its default value.
  mutating func clearContent() {self._content = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _content: String? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension ClientAction: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "RESET_SESSION"),
  ]
}

extension EncryptionAlgorithm: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "AES_CBC"),
    1: .same(proto: "AES_GCM"),
  ]
}

extension GenericMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "GenericMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "message_id"),
    2: .same(proto: "text"),
    3: .same(proto: "image"),
    4: .same(proto: "knock"),
    6: .same(proto: "lastRead"),
    7: .same(proto: "cleared"),
    8: .same(proto: "external"),
    9: .same(proto: "clientAction"),
    10: .same(proto: "calling"),
    11: .same(proto: "asset"),
    12: .same(proto: "hidden"),
    13: .same(proto: "location"),
    14: .same(proto: "deleted"),
    15: .same(proto: "edited"),
    16: .same(proto: "confirmation"),
    17: .same(proto: "reaction"),
    18: .same(proto: "ephemeral"),
    19: .same(proto: "availability"),
  ]

  fileprivate class _StorageClass {
    var _messageID: String? = nil
    var _content: GenericMessage.OneOf_Content?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _messageID = source._messageID
      _content = source._content
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._messageID == nil {return false}
      switch _storage._content {
      case .text(let v)?: if !v.isInitialized {return false}
      case .image(let v)?: if !v.isInitialized {return false}
      case .knock(let v)?: if !v.isInitialized {return false}
      case .lastRead(let v)?: if !v.isInitialized {return false}
      case .cleared(let v)?: if !v.isInitialized {return false}
      case .external(let v)?: if !v.isInitialized {return false}
      case .calling(let v)?: if !v.isInitialized {return false}
      case .asset(let v)?: if !v.isInitialized {return false}
      case .hidden(let v)?: if !v.isInitialized {return false}
      case .location(let v)?: if !v.isInitialized {return false}
      case .deleted(let v)?: if !v.isInitialized {return false}
      case .edited(let v)?: if !v.isInitialized {return false}
      case .confirmation(let v)?: if !v.isInitialized {return false}
      case .reaction(let v)?: if !v.isInitialized {return false}
      case .ephemeral(let v)?: if !v.isInitialized {return false}
      case .availability(let v)?: if !v.isInitialized {return false}
      default: break
      }
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._messageID)
        case 2:
          var v: Text?
          if let current = _storage._content {
            try decoder.handleConflictingOneOf()
            if case .text(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._content = .text(v)}
        case 3:
          var v: ImageAsset?
          if let current = _storage._content {
            try decoder.handleConflictingOneOf()
            if case .image(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._content = .image(v)}
        case 4:
          var v: Knock?
          if let current = _storage._content {
            try decoder.handleConflictingOneOf()
            if case .knock(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._content = .knock(v)}
        case 6:
          var v: LastRead?
          if let current = _storage._content {
            try decoder.handleConflictingOneOf()
            if case .lastRead(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._content = .lastRead(v)}
        case 7:
          var v: Cleared?
          if let current = _storage._content {
            try decoder.handleConflictingOneOf()
            if case .cleared(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._content = .cleared(v)}
        case 8:
          var v: External?
          if let current = _storage._content {
            try decoder.handleConflictingOneOf()
            if case .external(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._content = .external(v)}
        case 9:
          if _storage._content != nil {try decoder.handleConflictingOneOf()}
          var v: ClientAction?
          try decoder.decodeSingularEnumField(value: &v)
          if let v = v {_storage._content = .clientAction(v)}
        case 10:
          var v: Calling?
          if let current = _storage._content {
            try decoder.handleConflictingOneOf()
            if case .calling(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._content = .calling(v)}
        case 11:
          var v: Asset?
          if let current = _storage._content {
            try decoder.handleConflictingOneOf()
            if case .asset(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._content = .asset(v)}
        case 12:
          var v: MessageHide?
          if let current = _storage._content {
            try decoder.handleConflictingOneOf()
            if case .hidden(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._content = .hidden(v)}
        case 13:
          var v: Location?
          if let current = _storage._content {
            try decoder.handleConflictingOneOf()
            if case .location(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._content = .location(v)}
        case 14:
          var v: MessageDelete?
          if let current = _storage._content {
            try decoder.handleConflictingOneOf()
            if case .deleted(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._content = .deleted(v)}
        case 15:
          var v: MessageEdit?
          if let current = _storage._content {
            try decoder.handleConflictingOneOf()
            if case .edited(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._content = .edited(v)}
        case 16:
          var v: Confirmation?
          if let current = _storage._content {
            try decoder.handleConflictingOneOf()
            if case .confirmation(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._content = .confirmation(v)}
        case 17:
          var v: Reaction?
          if let current = _storage._content {
            try decoder.handleConflictingOneOf()
            if case .reaction(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._content = .reaction(v)}
        case 18:
          var v: Ephemeral?
          if let current = _storage._content {
            try decoder.handleConflictingOneOf()
            if case .ephemeral(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._content = .ephemeral(v)}
        case 19:
          var v: Availability?
          if let current = _storage._content {
            try decoder.handleConflictingOneOf()
            if case .availability(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._content = .availability(v)}
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._messageID {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      }
      switch _storage._content {
      case .text(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case .image(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      case .knock(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      case .lastRead(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      case .cleared(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      case .external(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      case .clientAction(let v)?:
        try visitor.visitSingularEnumField(value: v, fieldNumber: 9)
      case .calling(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      case .asset(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      case .hidden(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      case .location(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      case .deleted(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      case .edited(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      case .confirmation(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      case .reaction(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      case .ephemeral(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      case .availability(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GenericMessage, rhs: GenericMessage) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._messageID != rhs_storage._messageID {return false}
        if _storage._content != rhs_storage._content {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Availability: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Availability"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
  ]

  public var isInitialized: Bool {
    if self._type == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self._type)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Availability, rhs: Availability) -> Bool {
    if lhs._type != rhs._type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Availability.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NONE"),
    1: .same(proto: "AVAILABLE"),
    2: .same(proto: "AWAY"),
    3: .same(proto: "BUSY"),
  ]
}

extension Ephemeral: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Ephemeral"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "expire_after_millis"),
    2: .same(proto: "text"),
    3: .same(proto: "image"),
    4: .same(proto: "knock"),
    5: .same(proto: "asset"),
    6: .same(proto: "location"),
  ]

  fileprivate class _StorageClass {
    var _expireAfterMillis: Int64? = nil
    var _content: Ephemeral.OneOf_Content?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _expireAfterMillis = source._expireAfterMillis
      _content = source._content
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._expireAfterMillis == nil {return false}
      switch _storage._content {
      case .text(let v)?: if !v.isInitialized {return false}
      case .image(let v)?: if !v.isInitialized {return false}
      case .knock(let v)?: if !v.isInitialized {return false}
      case .asset(let v)?: if !v.isInitialized {return false}
      case .location(let v)?: if !v.isInitialized {return false}
      default: break
      }
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularInt64Field(value: &_storage._expireAfterMillis)
        case 2:
          var v: Text?
          if let current = _storage._content {
            try decoder.handleConflictingOneOf()
            if case .text(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._content = .text(v)}
        case 3:
          var v: ImageAsset?
          if let current = _storage._content {
            try decoder.handleConflictingOneOf()
            if case .image(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._content = .image(v)}
        case 4:
          var v: Knock?
          if let current = _storage._content {
            try decoder.handleConflictingOneOf()
            if case .knock(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._content = .knock(v)}
        case 5:
          var v: Asset?
          if let current = _storage._content {
            try decoder.handleConflictingOneOf()
            if case .asset(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._content = .asset(v)}
        case 6:
          var v: Location?
          if let current = _storage._content {
            try decoder.handleConflictingOneOf()
            if case .location(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._content = .location(v)}
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._expireAfterMillis {
        try visitor.visitSingularInt64Field(value: v, fieldNumber: 1)
      }
      switch _storage._content {
      case .text(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case .image(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      case .knock(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      case .asset(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      case .location(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ephemeral, rhs: Ephemeral) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._expireAfterMillis != rhs_storage._expireAfterMillis {return false}
        if _storage._content != rhs_storage._content {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Text: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Text"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "content"),
    3: .standard(proto: "link_preview"),
    4: .same(proto: "mentions"),
    5: .same(proto: "quote"),
  ]

  fileprivate class _StorageClass {
    var _content: String? = nil
    var _linkPreview: [LinkPreview] = []
    var _mentions: [Mention] = []
    var _quote: Quote? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _content = source._content
      _linkPreview = source._linkPreview
      _mentions = source._mentions
      _quote = source._quote
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._content == nil {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._linkPreview) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._mentions) {return false}
      if let v = _storage._quote, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._content)
        case 3: try decoder.decodeRepeatedMessageField(value: &_storage._linkPreview)
        case 4: try decoder.decodeRepeatedMessageField(value: &_storage._mentions)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._quote)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._content {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      }
      if !_storage._linkPreview.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._linkPreview, fieldNumber: 3)
      }
      if !_storage._mentions.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._mentions, fieldNumber: 4)
      }
      if let v = _storage._quote {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Text, rhs: Text) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._content != rhs_storage._content {return false}
        if _storage._linkPreview != rhs_storage._linkPreview {return false}
        if _storage._mentions != rhs_storage._mentions {return false}
        if _storage._quote != rhs_storage._quote {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Knock: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Knock"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "hot_knock"),
  ]

  public var isInitialized: Bool {
    if self._hotKnock == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBoolField(value: &self._hotKnock)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._hotKnock {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Knock, rhs: Knock) -> Bool {
    if lhs._hotKnock != rhs._hotKnock {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension LinkPreview: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "LinkPreview"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "url"),
    2: .standard(proto: "url_offset"),
    3: .same(proto: "article"),
    5: .standard(proto: "permanent_url"),
    6: .same(proto: "title"),
    7: .same(proto: "summary"),
    8: .same(proto: "image"),
    9: .same(proto: "tweet"),
  ]

  fileprivate class _StorageClass {
    var _url: String? = nil
    var _urlOffset: Int32? = nil
    var _preview: LinkPreview.OneOf_Preview?
    var _permanentURL: String? = nil
    var _title: String? = nil
    var _summary: String? = nil
    var _image: Asset? = nil
    var _metaData: LinkPreview.OneOf_MetaData?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _url = source._url
      _urlOffset = source._urlOffset
      _preview = source._preview
      _permanentURL = source._permanentURL
      _title = source._title
      _summary = source._summary
      _image = source._image
      _metaData = source._metaData
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._url == nil {return false}
      if _storage._urlOffset == nil {return false}
      if case .article(let v)? = _storage._preview, !v.isInitialized {return false}
      if let v = _storage._image, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._url)
        case 2: try decoder.decodeSingularInt32Field(value: &_storage._urlOffset)
        case 3:
          var v: Article?
          if let current = _storage._preview {
            try decoder.handleConflictingOneOf()
            if case .article(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._preview = .article(v)}
        case 5: try decoder.decodeSingularStringField(value: &_storage._permanentURL)
        case 6: try decoder.decodeSingularStringField(value: &_storage._title)
        case 7: try decoder.decodeSingularStringField(value: &_storage._summary)
        case 8: try decoder.decodeSingularMessageField(value: &_storage._image)
        case 9:
          var v: Tweet?
          if let current = _storage._metaData {
            try decoder.handleConflictingOneOf()
            if case .tweet(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._metaData = .tweet(v)}
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._url {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      }
      if let v = _storage._urlOffset {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
      }
      if case .article(let v)? = _storage._preview {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._permanentURL {
        try visitor.visitSingularStringField(value: v, fieldNumber: 5)
      }
      if let v = _storage._title {
        try visitor.visitSingularStringField(value: v, fieldNumber: 6)
      }
      if let v = _storage._summary {
        try visitor.visitSingularStringField(value: v, fieldNumber: 7)
      }
      if let v = _storage._image {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
      if case .tweet(let v)? = _storage._metaData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: LinkPreview, rhs: LinkPreview) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._url != rhs_storage._url {return false}
        if _storage._urlOffset != rhs_storage._urlOffset {return false}
        if _storage._preview != rhs_storage._preview {return false}
        if _storage._permanentURL != rhs_storage._permanentURL {return false}
        if _storage._title != rhs_storage._title {return false}
        if _storage._summary != rhs_storage._summary {return false}
        if _storage._image != rhs_storage._image {return false}
        if _storage._metaData != rhs_storage._metaData {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tweet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Tweet"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "author"),
    2: .same(proto: "username"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._author)
      case 2: try decoder.decodeSingularStringField(value: &self._username)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._author {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._username {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tweet, rhs: Tweet) -> Bool {
    if lhs._author != rhs._author {return false}
    if lhs._username != rhs._username {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Article: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Article"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "permanent_url"),
    2: .same(proto: "title"),
    3: .same(proto: "summary"),
    4: .same(proto: "image"),
  ]

  fileprivate class _StorageClass {
    var _permanentURL: String? = nil
    var _title: String? = nil
    var _summary: String? = nil
    var _image: Asset? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _permanentURL = source._permanentURL
      _title = source._title
      _summary = source._summary
      _image = source._image
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._permanentURL == nil {return false}
      if let v = _storage._image, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._permanentURL)
        case 2: try decoder.decodeSingularStringField(value: &_storage._title)
        case 3: try decoder.decodeSingularStringField(value: &_storage._summary)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._image)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._permanentURL {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      }
      if let v = _storage._title {
        try visitor.visitSingularStringField(value: v, fieldNumber: 2)
      }
      if let v = _storage._summary {
        try visitor.visitSingularStringField(value: v, fieldNumber: 3)
      }
      if let v = _storage._image {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Article, rhs: Article) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._permanentURL != rhs_storage._permanentURL {return false}
        if _storage._title != rhs_storage._title {return false}
        if _storage._summary != rhs_storage._summary {return false}
        if _storage._image != rhs_storage._image {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mention: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Mention"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "start"),
    2: .same(proto: "length"),
    3: .standard(proto: "user_id"),
  ]

  public var isInitialized: Bool {
    if self._start == nil {return false}
    if self._length == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt32Field(value: &self._start)
      case 2: try decoder.decodeSingularInt32Field(value: &self._length)
      case 3:
        if self.mentionType != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.mentionType = .userID(v)}
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._start {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._length {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    }
    if case .userID(let v)? = self.mentionType {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mention, rhs: Mention) -> Bool {
    if lhs._start != rhs._start {return false}
    if lhs._length != rhs._length {return false}
    if lhs.mentionType != rhs.mentionType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension LastRead: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "LastRead"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "conversation_id"),
    2: .standard(proto: "last_read_timestamp"),
  ]

  public var isInitialized: Bool {
    if self._conversationID == nil {return false}
    if self._lastReadTimestamp == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._conversationID)
      case 2: try decoder.decodeSingularInt64Field(value: &self._lastReadTimestamp)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._conversationID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._lastReadTimestamp {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: LastRead, rhs: LastRead) -> Bool {
    if lhs._conversationID != rhs._conversationID {return false}
    if lhs._lastReadTimestamp != rhs._lastReadTimestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cleared: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Cleared"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "conversation_id"),
    2: .standard(proto: "cleared_timestamp"),
  ]

  public var isInitialized: Bool {
    if self._conversationID == nil {return false}
    if self._clearedTimestamp == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._conversationID)
      case 2: try decoder.decodeSingularInt64Field(value: &self._clearedTimestamp)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._conversationID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._clearedTimestamp {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cleared, rhs: Cleared) -> Bool {
    if lhs._conversationID != rhs._conversationID {return false}
    if lhs._clearedTimestamp != rhs._clearedTimestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MessageHide: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "MessageHide"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "conversation_id"),
    2: .standard(proto: "message_id"),
  ]

  public var isInitialized: Bool {
    if self._conversationID == nil {return false}
    if self._messageID == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._conversationID)
      case 2: try decoder.decodeSingularStringField(value: &self._messageID)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._conversationID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._messageID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: MessageHide, rhs: MessageHide) -> Bool {
    if lhs._conversationID != rhs._conversationID {return false}
    if lhs._messageID != rhs._messageID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MessageDelete: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "MessageDelete"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "message_id"),
  ]

  public var isInitialized: Bool {
    if self._messageID == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._messageID)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._messageID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: MessageDelete, rhs: MessageDelete) -> Bool {
    if lhs._messageID != rhs._messageID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MessageEdit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "MessageEdit"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "replacing_message_id"),
    2: .same(proto: "text"),
  ]

  fileprivate class _StorageClass {
    var _replacingMessageID: String? = nil
    var _content: MessageEdit.OneOf_Content?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _replacingMessageID = source._replacingMessageID
      _content = source._content
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._replacingMessageID == nil {return false}
      if case .text(let v)? = _storage._content, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._replacingMessageID)
        case 2:
          var v: Text?
          if let current = _storage._content {
            try decoder.handleConflictingOneOf()
            if case .text(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._content = .text(v)}
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._replacingMessageID {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      }
      if case .text(let v)? = _storage._content {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: MessageEdit, rhs: MessageEdit) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._replacingMessageID != rhs_storage._replacingMessageID {return false}
        if _storage._content != rhs_storage._content {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Quote: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Quote"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "quoted_message_id"),
    2: .standard(proto: "quoted_message_sha256"),
  ]

  public var isInitialized: Bool {
    if self._quotedMessageID == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._quotedMessageID)
      case 2: try decoder.decodeSingularBytesField(value: &self._quotedMessageSha256)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._quotedMessageID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._quotedMessageSha256 {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Quote, rhs: Quote) -> Bool {
    if lhs._quotedMessageID != rhs._quotedMessageID {return false}
    if lhs._quotedMessageSha256 != rhs._quotedMessageSha256 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Confirmation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Confirmation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "type"),
    1: .standard(proto: "first_message_id"),
    3: .standard(proto: "more_message_ids"),
  ]

  public var isInitialized: Bool {
    if self._type == nil {return false}
    if self._firstMessageID == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._firstMessageID)
      case 2: try decoder.decodeSingularEnumField(value: &self._type)
      case 3: try decoder.decodeRepeatedStringField(value: &self.moreMessageIds)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._firstMessageID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    }
    if !self.moreMessageIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.moreMessageIds, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Confirmation, rhs: Confirmation) -> Bool {
    if lhs._type != rhs._type {return false}
    if lhs._firstMessageID != rhs._firstMessageID {return false}
    if lhs.moreMessageIds != rhs.moreMessageIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Confirmation.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DELIVERED"),
    1: .same(proto: "READ"),
  ]
}

extension Location: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Location"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "longitude"),
    2: .same(proto: "latitude"),
    3: .same(proto: "name"),
    4: .same(proto: "zoom"),
  ]

  public var isInitialized: Bool {
    if self._longitude == nil {return false}
    if self._latitude == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularFloatField(value: &self._longitude)
      case 2: try decoder.decodeSingularFloatField(value: &self._latitude)
      case 3: try decoder.decodeSingularStringField(value: &self._name)
      case 4: try decoder.decodeSingularInt32Field(value: &self._zoom)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._longitude {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 1)
    }
    if let v = self._latitude {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 2)
    }
    if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    if let v = self._zoom {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Location, rhs: Location) -> Bool {
    if lhs._longitude != rhs._longitude {return false}
    if lhs._latitude != rhs._latitude {return false}
    if lhs._name != rhs._name {return false}
    if lhs._zoom != rhs._zoom {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ImageAsset: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ImageAsset"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tag"),
    2: .same(proto: "width"),
    3: .same(proto: "height"),
    4: .standard(proto: "original_width"),
    5: .standard(proto: "original_height"),
    6: .standard(proto: "mime_type"),
    7: .same(proto: "size"),
    8: .standard(proto: "otr_key"),
    9: .standard(proto: "mac_key"),
    10: .same(proto: "mac"),
    11: .same(proto: "sha256"),
  ]

  public var isInitialized: Bool {
    if self._tag == nil {return false}
    if self._width == nil {return false}
    if self._height == nil {return false}
    if self._originalWidth == nil {return false}
    if self._originalHeight == nil {return false}
    if self._mimeType == nil {return false}
    if self._size == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._tag)
      case 2: try decoder.decodeSingularInt32Field(value: &self._width)
      case 3: try decoder.decodeSingularInt32Field(value: &self._height)
      case 4: try decoder.decodeSingularInt32Field(value: &self._originalWidth)
      case 5: try decoder.decodeSingularInt32Field(value: &self._originalHeight)
      case 6: try decoder.decodeSingularStringField(value: &self._mimeType)
      case 7: try decoder.decodeSingularInt32Field(value: &self._size)
      case 8: try decoder.decodeSingularBytesField(value: &self._otrKey)
      case 9: try decoder.decodeSingularBytesField(value: &self._macKey)
      case 10: try decoder.decodeSingularBytesField(value: &self._mac)
      case 11: try decoder.decodeSingularBytesField(value: &self._sha256)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._tag {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._width {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    }
    if let v = self._height {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    }
    if let v = self._originalWidth {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 4)
    }
    if let v = self._originalHeight {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 5)
    }
    if let v = self._mimeType {
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    }
    if let v = self._size {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 7)
    }
    if let v = self._otrKey {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 8)
    }
    if let v = self._macKey {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 9)
    }
    if let v = self._mac {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 10)
    }
    if let v = self._sha256 {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ImageAsset, rhs: ImageAsset) -> Bool {
    if lhs._tag != rhs._tag {return false}
    if lhs._width != rhs._width {return false}
    if lhs._height != rhs._height {return false}
    if lhs._originalWidth != rhs._originalWidth {return false}
    if lhs._originalHeight != rhs._originalHeight {return false}
    if lhs._mimeType != rhs._mimeType {return false}
    if lhs._size != rhs._size {return false}
    if lhs._otrKey != rhs._otrKey {return false}
    if lhs._macKey != rhs._macKey {return false}
    if lhs._mac != rhs._mac {return false}
    if lhs._sha256 != rhs._sha256 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Asset: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Asset"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "original"),
    3: .standard(proto: "not_uploaded"),
    4: .same(proto: "uploaded"),
    5: .same(proto: "preview"),
  ]

  fileprivate class _StorageClass {
    var _original: Asset.Original? = nil
    var _status: Asset.OneOf_Status?
    var _preview: Asset.Preview? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _original = source._original
      _status = source._status
      _preview = source._preview
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._original, !v.isInitialized {return false}
      if case .uploaded(let v)? = _storage._status, !v.isInitialized {return false}
      if let v = _storage._preview, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._original)
        case 3:
          if _storage._status != nil {try decoder.handleConflictingOneOf()}
          var v: Asset.NotUploaded?
          try decoder.decodeSingularEnumField(value: &v)
          if let v = v {_storage._status = .notUploaded(v)}
        case 4:
          var v: Asset.RemoteData?
          if let current = _storage._status {
            try decoder.handleConflictingOneOf()
            if case .uploaded(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._status = .uploaded(v)}
        case 5: try decoder.decodeSingularMessageField(value: &_storage._preview)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._original {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      switch _storage._status {
      case .notUploaded(let v)?:
        try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
      case .uploaded(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      case nil: break
      }
      if let v = _storage._preview {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Asset, rhs: Asset) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._original != rhs_storage._original {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._preview != rhs_storage._preview {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Asset.NotUploaded: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CANCELLED"),
    1: .same(proto: "FAILED"),
  ]
}

extension Asset.Original: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Asset.protoMessageName + ".Original"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "mime_type"),
    2: .same(proto: "size"),
    3: .same(proto: "name"),
    4: .same(proto: "image"),
    5: .same(proto: "video"),
    6: .same(proto: "audio"),
    7: .same(proto: "source"),
    8: .same(proto: "caption"),
  ]

  fileprivate class _StorageClass {
    var _mimeType: String? = nil
    var _size: UInt64? = nil
    var _name: String? = nil
    var _metaData: Asset.Original.OneOf_MetaData?
    var _source: String? = nil
    var _caption: String? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _mimeType = source._mimeType
      _size = source._size
      _name = source._name
      _metaData = source._metaData
      _source = source._source
      _caption = source._caption
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._mimeType == nil {return false}
      if _storage._size == nil {return false}
      if case .image(let v)? = _storage._metaData, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._mimeType)
        case 2: try decoder.decodeSingularUInt64Field(value: &_storage._size)
        case 3: try decoder.decodeSingularStringField(value: &_storage._name)
        case 4:
          var v: Asset.ImageMetaData?
          if let current = _storage._metaData {
            try decoder.handleConflictingOneOf()
            if case .image(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._metaData = .image(v)}
        case 5:
          var v: Asset.VideoMetaData?
          if let current = _storage._metaData {
            try decoder.handleConflictingOneOf()
            if case .video(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._metaData = .video(v)}
        case 6:
          var v: Asset.AudioMetaData?
          if let current = _storage._metaData {
            try decoder.handleConflictingOneOf()
            if case .audio(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._metaData = .audio(v)}
        case 7: try decoder.decodeSingularStringField(value: &_storage._source)
        case 8: try decoder.decodeSingularStringField(value: &_storage._caption)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._mimeType {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      }
      if let v = _storage._size {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
      }
      if let v = _storage._name {
        try visitor.visitSingularStringField(value: v, fieldNumber: 3)
      }
      switch _storage._metaData {
      case .image(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      case .video(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      case .audio(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      case nil: break
      }
      if let v = _storage._source {
        try visitor.visitSingularStringField(value: v, fieldNumber: 7)
      }
      if let v = _storage._caption {
        try visitor.visitSingularStringField(value: v, fieldNumber: 8)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Asset.Original, rhs: Asset.Original) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._mimeType != rhs_storage._mimeType {return false}
        if _storage._size != rhs_storage._size {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._metaData != rhs_storage._metaData {return false}
        if _storage._source != rhs_storage._source {return false}
        if _storage._caption != rhs_storage._caption {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Asset.Preview: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Asset.protoMessageName + ".Preview"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "mime_type"),
    2: .same(proto: "size"),
    3: .same(proto: "remote"),
    4: .same(proto: "image"),
  ]

  fileprivate class _StorageClass {
    var _mimeType: String? = nil
    var _size: UInt64? = nil
    var _remote: Asset.RemoteData? = nil
    var _metaData: Asset.Preview.OneOf_MetaData?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _mimeType = source._mimeType
      _size = source._size
      _remote = source._remote
      _metaData = source._metaData
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._mimeType == nil {return false}
      if _storage._size == nil {return false}
      if let v = _storage._remote, !v.isInitialized {return false}
      if case .image(let v)? = _storage._metaData, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._mimeType)
        case 2: try decoder.decodeSingularUInt64Field(value: &_storage._size)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._remote)
        case 4:
          var v: Asset.ImageMetaData?
          if let current = _storage._metaData {
            try decoder.handleConflictingOneOf()
            if case .image(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._metaData = .image(v)}
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._mimeType {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      }
      if let v = _storage._size {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
      }
      if let v = _storage._remote {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if case .image(let v)? = _storage._metaData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Asset.Preview, rhs: Asset.Preview) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._mimeType != rhs_storage._mimeType {return false}
        if _storage._size != rhs_storage._size {return false}
        if _storage._remote != rhs_storage._remote {return false}
        if _storage._metaData != rhs_storage._metaData {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Asset.ImageMetaData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Asset.protoMessageName + ".ImageMetaData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "width"),
    2: .same(proto: "height"),
    3: .same(proto: "tag"),
  ]

  public var isInitialized: Bool {
    if self._width == nil {return false}
    if self._height == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt32Field(value: &self._width)
      case 2: try decoder.decodeSingularInt32Field(value: &self._height)
      case 3: try decoder.decodeSingularStringField(value: &self._tag)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._width {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._height {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    }
    if let v = self._tag {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Asset.ImageMetaData, rhs: Asset.ImageMetaData) -> Bool {
    if lhs._width != rhs._width {return false}
    if lhs._height != rhs._height {return false}
    if lhs._tag != rhs._tag {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Asset.VideoMetaData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Asset.protoMessageName + ".VideoMetaData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "width"),
    2: .same(proto: "height"),
    3: .standard(proto: "duration_in_millis"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt32Field(value: &self._width)
      case 2: try decoder.decodeSingularInt32Field(value: &self._height)
      case 3: try decoder.decodeSingularUInt64Field(value: &self._durationInMillis)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._width {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._height {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    }
    if let v = self._durationInMillis {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Asset.VideoMetaData, rhs: Asset.VideoMetaData) -> Bool {
    if lhs._width != rhs._width {return false}
    if lhs._height != rhs._height {return false}
    if lhs._durationInMillis != rhs._durationInMillis {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Asset.AudioMetaData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Asset.protoMessageName + ".AudioMetaData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "duration_in_millis"),
    3: .standard(proto: "normalized_loudness"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt64Field(value: &self._durationInMillis)
      case 3: try decoder.decodeSingularBytesField(value: &self._normalizedLoudness)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._durationInMillis {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    }
    if let v = self._normalizedLoudness {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Asset.AudioMetaData, rhs: Asset.AudioMetaData) -> Bool {
    if lhs._durationInMillis != rhs._durationInMillis {return false}
    if lhs._normalizedLoudness != rhs._normalizedLoudness {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Asset.RemoteData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Asset.protoMessageName + ".RemoteData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "otr_key"),
    2: .same(proto: "sha256"),
    3: .standard(proto: "asset_id"),
    5: .standard(proto: "asset_token"),
    6: .same(proto: "encryption"),
  ]

  public var isInitialized: Bool {
    if self._otrKey == nil {return false}
    if self._sha256 == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self._otrKey)
      case 2: try decoder.decodeSingularBytesField(value: &self._sha256)
      case 3: try decoder.decodeSingularStringField(value: &self._assetID)
      case 5: try decoder.decodeSingularStringField(value: &self._assetToken)
      case 6: try decoder.decodeSingularEnumField(value: &self._encryption)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._otrKey {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    }
    if let v = self._sha256 {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    }
    if let v = self._assetID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    if let v = self._assetToken {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    }
    if let v = self._encryption {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Asset.RemoteData, rhs: Asset.RemoteData) -> Bool {
    if lhs._otrKey != rhs._otrKey {return false}
    if lhs._sha256 != rhs._sha256 {return false}
    if lhs._assetID != rhs._assetID {return false}
    if lhs._assetToken != rhs._assetToken {return false}
    if lhs._encryption != rhs._encryption {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension External: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "External"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "otr_key"),
    2: .same(proto: "sha256"),
    3: .same(proto: "encryption"),
  ]

  public var isInitialized: Bool {
    if self._otrKey == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self._otrKey)
      case 2: try decoder.decodeSingularBytesField(value: &self._sha256)
      case 3: try decoder.decodeSingularEnumField(value: &self._encryption)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._otrKey {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    }
    if let v = self._sha256 {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    }
    if let v = self._encryption {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: External, rhs: External) -> Bool {
    if lhs._otrKey != rhs._otrKey {return false}
    if lhs._sha256 != rhs._sha256 {return false}
    if lhs._encryption != rhs._encryption {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Reaction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Reaction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "emoji"),
    2: .standard(proto: "message_id"),
  ]

  public var isInitialized: Bool {
    if self._messageID == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._emoji)
      case 2: try decoder.decodeSingularStringField(value: &self._messageID)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._emoji {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._messageID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Reaction, rhs: Reaction) -> Bool {
    if lhs._emoji != rhs._emoji {return false}
    if lhs._messageID != rhs._messageID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Calling: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Calling"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "content"),
  ]

  public var isInitialized: Bool {
    if self._content == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._content)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._content {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Calling, rhs: Calling) -> Bool {
    if lhs._content != rhs._content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
